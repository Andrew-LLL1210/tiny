
fn printErrors(
    errors: []const tiny.Error,
    gpa: Allocator,
    source: []const u8,
    file_name: []const u8,
    w: anytype,
) !void {
    for (errors) |err| switch (err) {
        .duplicate_label => |spans| {
            const err_line = spans[0].line(source).line;
            const err_pos = spans[0].range(source).start;
            const err_underline = try spans[0].underline(gpa, source);
            defer gpa.free(err_underline);

            const note_line = spans[1].line(source).line;
            const note_pos = spans[1].range(source).start;
            const note_underline = try spans[1].underline(gpa, source);
            defer gpa.free(note_underline);

            try w.print("{s}:{d}:{d}: error: duplicate label\n{s}\n{s}\n" ++
                "{s}:{d}:{d}: note: original label here\n{s}\n{s}\n\n", .{
                file_name,
                err_pos.row + 1,
                err_pos.col + 1,
                err_line,
                err_underline,
                file_name,
                note_pos.row + 1,
                note_pos.col + 1,
                note_line,
                note_underline,
            });
        },
        .builtin_label_redefinition => |span_name| {
            const line = span_name[0].line(source).line;
            const pos = span_name[0].range(source).start;
            const underline = try span_name[0].underline(gpa, source);
            defer gpa.free(underline);

            try w.print("{s}:{d}:{d}: error: redefinition of builtin label {s}\n{s}\n{s}\n\n", .{
                file_name,
                pos.row + 1,
                pos.col + 1,
                @as([]const u8, span_name[1]),
                line,
                underline,
            });
        },
        inline else => |span| {
            _ = @as(Span, span);
            const line = span.line(source).line;
            const pos = span.range(source).start;
            const underline = try span.underline(gpa, source);
            defer gpa.free(underline);

            try w.print("{s}:{d}:{d}: error: {s}\n{s}\n{s}\n\n", .{
                file_name,
                pos.row + 1,
                pos.col + 1,
                @tagName(err),
                line,
                underline,
            });
        },
    };
}

fn printRunError(err: anyerror, node: Node, gpa: Allocator, source: []const u8, file_name: []const u8, w: anytype) !void {
    const line = node.jointSpan().line(source);
    const pos = node.jointSpan().range(source).start;
    const line2 = try gpa.dupe(u8, line.line);
    defer gpa.free(line2);

    for (line2, line.start..) |*char, i| if (char.* != '\t') {
        char.* = if (node.jointSpan().start <= i and i < node.jointSpan().end) '^' else ' ';
    };

    try w.print("{s}:{d}:{d}: error: {s}\n{s}\n{s}\n\n", .{
        file_name,
        pos.row + 1,
        pos.col + 1,
        @errorName(err),
        line.line,
        line2,
    });
}

const Span = tiny.Span;
